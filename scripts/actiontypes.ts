import fs from "node:fs";
import * as ts from "typescript";
import YAML from "yaml";

interface Module {
  key: string;
  name: string;
  description: string;
}

interface Input {
  title: string;
  description: string;
  required: boolean;
  type: string;
}

interface Action extends Module {
  actionVerb: string;
  function: string;
  inputs: Map<string, Input>;
}

type Actions = Array<Action>;

const commonImports = [
  createImport("CommonEvent", "./forge/events"),
  createImport("RovoContext", "./rovo/action"),
];

// Interfaces should extend CommonEvent from "./forge/events"
const commonExtendsClause = ts.factory.createHeritageClause(
  ts.SyntaxKind.ExtendsKeyword,
  [
    ts.factory.createExpressionWithTypeArguments(
      ts.factory.createIdentifier("CommonEvent"),
      undefined,
    ),
  ],
);

const commonContextProperty = ts.factory.createPropertySignature(
  undefined,
  ts.factory.createIdentifier("context"),
  undefined,
  ts.factory.createTypeReferenceNode(
    ts.factory.createIdentifier("RovoContext"),
    undefined,
  ),
);

const forgeInputTypeMap: Map<string, number> = new Map([
  ["string", ts.SyntaxKind.StringKeyword],
  ["integer", ts.SyntaxKind.BigIntKeyword],
  ["number", ts.SyntaxKind.NumberKeyword],
  ["boolean", ts.SyntaxKind.BooleanKeyword],
]);

function createInputProperties(
  inputs: Map<string, Input>,
): Array<ts.PropertySignature> {
  return Array.from(inputs.entries()).map(([name, input]) => {
    return ts.factory.createPropertySignature(
      undefined,
      ts.factory.createIdentifier(name),
      input.required
        ? undefined
        : ts.factory.createToken(ts.SyntaxKind.QuestionToken),
      ts.factory.createKeywordTypeNode(
        forgeInputTypeMap.get(input.type) ?? ts.SyntaxKind.UndefinedKeyword,
      ),
    );
  });
}

function createImport(className: string, moduleReference: string) {
  return ts.factory.createImportDeclaration(
    undefined,
    ts.factory.createImportClause(
      true,
      undefined,
      ts.factory.createNamedImports([
        ts.factory.createImportSpecifier(
          false,
          undefined,
          ts.factory.createIdentifier(className),
        ),
      ]),
    ),
    ts.factory.createStringLiteral(moduleReference),
    undefined,
  );
}

function buildInterfaces(actions: Actions) {
  return actions.map((action) => {
    const inputs: Map<string, Input> = new Map(Object.entries(action.inputs));
    return ts.factory.createInterfaceDeclaration(
      [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createIdentifier(
        `${action.function.charAt(0).toUpperCase()}${action.function.slice(1)}Payload`,
      ),
      undefined, // typeParameters (optional)
      [commonExtendsClause],
      [...createInputProperties(inputs), commonContextProperty],
    );
  });
}

function readActions(manifestYaml: string): Actions | undefined {
  const parsedYaml = YAML.parse(manifestYaml, { mapAsMap: false }) as object;
  if (typeof parsedYaml !== "object") {
    return;
  }
  const manifestAsMap = new Map(Object.entries(parsedYaml));
  console.debug(
    `Manifest keys: [${Array.from(manifestAsMap.keys()).join(",")}]`,
  );
  if (manifestAsMap.get("modules") === undefined) {
    return;
  }
  const modulesAsMap = new Map(Object.entries(manifestAsMap.get("modules")));
  console.debug(`Module keys: [${Array.from(modulesAsMap.keys()).join(",")}]`);
  if (modulesAsMap.get("action") === undefined) {
    return;
  }
  const appActions = modulesAsMap.get("action") as Actions;
  console.debug(
    `Action keys: [${appActions
      .map((action) => {
        return action.key;
      })
      .join(",")}]`,
  );
  return appActions;
}

const manifestFile = fs.readFileSync("manifest.yml", "utf8");
const actions = readActions(manifestFile);
if (actions) {
  const draftFile = ts.createSourceFile(
    "actionpayload.ts",
    "",
    ts.ScriptTarget.Latest,
    /*setParentNodes*/ false,
    ts.ScriptKind.TS,
  );
  const tsPrinter = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const code = tsPrinter.printList(
    ts.ListFormat.MultiLine,
    ts.factory.createNodeArray([...commonImports, ...buildInterfaces(actions)]),
    draftFile,
  );
  /*
  import type { CommonEvent } from "./forge/events";
  import type { RovoContext } from "./rovo/action";
  export interface LogAssessmentPayload extends CommonEvent {
    assessment: string;
    context: RovoContext;
  }
  */
  const actionpayload = `
/*
Generated by npm run actiontypes
Using ../scripts/actiontypes.ts
Payload interfaces are kept in sync with Actions & Inputs defined in manifest.yml
*/
${code}`;
  console.log(actionpayload);
  fs.writeFileSync("./src/actionpayload.ts", actionpayload);
}
